# -*- coding: utf-8 -*-
"""Audrey Lab 5.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Ev5ZU_u0kGRnD3jLQ81FQh5a0U_Sj35n
"""

import matplotlib.pyplot as plt
from PIL import Image
import imageio.v2 as imageio

def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x,cmap='gray')
    ax.axis('off')
    fig.set_size_inches(20, 20)
    plt.show()

im = imageio.imread('https://lospec.com/palette-list/st-64-natural-1x.png') #import image of a color pallete

plot(im)

im.shape

plot(im[:,40:41,:])

im[:,40:41,:]

im = imageio.imread('https://lospec.com/palette-list/waverator-1x.png')

plot(im)

im



import numpy as np
import matplotlib.pyplot as plt

# Binary image
binary_image = np.array([ #defining a 3x3 matrix as a binary image (black and white, 0's=black, 1's=white)
    [0, 1, 0],
    [1, 1, 1],
    [0, 1, 0]
])

binary_image

plt.imshow(binary_image, cmap='gray') #plot the image, note cmap='gray' denotes that the colors are in grayscale

# Grayscale image
grayscale_image = np.array([
    [50, 100, 150],
    [200, 255, 200],
    [150, 100, 50]
])
plt.imshow(grayscale_image, cmap='gray', vmin=0, vmax=255) #adding min and max values so 0=black, 255=white

# Grayscale image
grayscale_image = np.array([ #values from 0 to 1, 0 being black and 1 being white
    [0.2, 0.4, 0.6], #dark to light
    [0.8, 1.0, 0.8],
    [0.6, 0.4, 0.2] #light to dark
])
plt.imshow(grayscale_image, cmap='gray')

# RGB image
rgb_image = np.array([
    [[255, 0, 0], [0, 255, 0], [0, 0, 255]],
    [[255, 255, 0], [0, 255, 255], [255, 0, 255]],
    [[128, 128, 128], [255, 255, 255], [0, 0, 0]] #creating an RGB image, no cmap='gray' so encompasses all colors
])

""" Note that these commands denote these corresponding colors:
 Red [1, 0, 0], Green [0, 1, 0], Blue [0, 0, 1]
Yellow [1, 1, 0] (red + green), Cyan [0, 1, 1] (green + blue), Magenta [1, 0, 1] (red + blue)
"""

rgb_image

plt.imshow(rgb_image) #shows the colored 3x3 array

# RGB image
rgb_image = np.array([
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
    [[1, 1, 0], [0, 1, 1], [1, 0, 1]],
    [[0.5, 0.5, 0.5], [1, 1, 1], [0, 0, 0]]
]) #creates an RGB array from 0 to 1 (3x3)

# RGB image
rgb_image = np.array([
    [[1, 0, 0], [0, 1, 0], [0, 0, 1]],
    [[1, 1, 0], [0, 1, 1], [1, 0, 1]],

]) #creates a RGB array of 0's and 1's to depict multiple colors (2x3)

rgb_image

plt.imshow(rgb_image*255) #plots the second version of the RGB image, multiplying it by 255 (range is now from 0 to 255)

#note that when I say x = np.zeros((2,2,3)) #initalizes the array with zeros, that is essentially filling the array with black (0 denotes black)

x = np.zeros((2,2,3)) #initalizes the array with zeros
x[:,:,0] = 1 #displays red pixels
plt.imshow(x)

x = np.zeros((2,2,3)) #initalizes the array with zeros
x[:,:,1] = 1 #displays green pixels
plt.imshow(x)

x = np.zeros((2,2,3)) #initalizes the array with zeros
x[:,:,2] = 1 #displays blue pixels
plt.imshow(x)

x = np.zeros((2,2,3)) #initalizes the array with zeros
x[:,:,0] = 1 #red
x[:,:,1] = 1 #green
#both to display yellow pixels
plt.imshow(x)

x = np.zeros((2,2,3)) #initalizes the array with zeros
x[:,:,1] = 1 #green
x[:,:,2] = 1 #blue
#both to display cyan pixels
plt.imshow(x)

x = np.zeros((2,2,3)) #initalizes the array with zeros
x[:,:,0] = 1 #red
x[:,:,2] = 1 #blue
#both to display magenta pixels
plt.imshow(x)

x = np.zeros((2,2,3)) #initalizes the array with zeros
x[:,:,0] = 0.5
x[:,:,1] = 0.5
x[:,:,2] = 0.5 #displays gray pixels (all RGB channels between 0 and 1)
plt.imshow(x)

x = np.zeros((2,2,3)) #initalizes the array with zeros
x[:,:,0] = 1
x[:,:,1] = 1
x[:,:,2] = 1 #displays white pixels, RGB channels=1
plt.imshow(x)

x = np.zeros((2,2,3)) #initalizes the array with zeros
x[:,:,0] = 0
x[:,:,1] = 0
x[:,:,2] = 0 #displays black pixels, setting red green and blue color channels to 0
plt.imshow(x)



r = np.random.rand() #takes a random number and defines it as r

r



r = np.random.rand()
g = np.random.rand()
b = np.random.rand()
#creates a random color

x = np.zeros((2,2,3)) #initalizes the array with zeros

x[:,:,0] = r
x[:,:,1] = g
x[:,:,2] = b #fills the random red green and blue components


plt.imshow(x) #shows the random color



for i in range(5): #loop 5 times

    z = np.ones((10,10,3)) #initalize the array with 1's (white)

    r = np.random.rand()
    g = np.random.rand()
    b = np.random.rand()

    print(r,g,b)

    z[:,:,0] = r
    z[:,:,1] = g #assigning their values to red, green, and blue
    z[:,:,2] = b

    plt.imshow(z); #displays 5 random colors
    plt.show()





for i in range(5): #loop 5 times

    z1 = np.ones((10,10,3)) #initalize both z1 and z2 with ones, making them white
    z2 = np.ones((10,10,3))

    r = np.random.rand()
    g = np.random.rand()
    b = np.random.rand() #random values for RGB

    z1[:,:,0] = r
    z1[:,:,1] = g
    z1[:,:,2] = b #fills z1 with the RGB values

    z2[:,:,0] = 1-r #fills z2 with 1-the corresponding RGB values (complementary color)
    z2[:,:,1] = 1-g
    z2[:,:,2] = 1-b

    z3 = np.hstack((z1,z2)) #combine the colors to form a new image z3

    plt.imshow(z3);
    plt.show() #displays the image



z1 = np.ones((10,10,3)) #initialize the array with ones
z1[:,:,0] = np.random.rand() #fills z1 with random RGB values
z1[:,:,1] = np.random.rand()
z1[:,:,2] = np.random.rand()

z2 = np.ones((10,10,3)) #initialize the array with ones
z2[:,:,0] = np.random.rand() #fills z2 with random RGB values
z2[:,:,1] = np.random.rand()
z2[:,:,2] = np.random.rand()

zavg = (z1+z2)/2 #calculates the average RGB values between z1 and z2

z3 = np.hstack((z1,zavg,z2)) #plots the avg as well

plt.imshow(z3);
plt.show()



z1 = np.ones((10,10,3)) #initialize the array with ones
z1[:,:,0] = np.random.rand() #fills z1 with random RGB values
z1[:,:,1] = np.random.rand()
z1[:,:,2] = np.random.rand()

z2 = np.ones((10,10,3)) #initialize the array with ones
z2[:,:,0] = np.random.rand() #fills z2 with random RGB values
z2[:,:,1] = np.random.rand()
z2[:,:,2] = np.random.rand()

zavg = (z1+z2)/2 #calculates the avg of z1 and z2

z1a = (z1+zavg)/2 #adds the avg to z1 and z2 and divides by 2 (gradient)
z2a = (z2+zavg)/2

z3 = np.hstack((z1,z1a,zavg,z2a,z2))

plt.imshow(z3); #plots all 5, creating a gradient-like effect
plt.show()





for i in range(100): #loops 100 times, follows the same steps as the last code block to create graidents
#effectively creates color palettes for 100 random colors
    z1 = np.ones((10,10,3))
    z1[:,:,0] = np.random.rand()
    z1[:,:,1] = np.random.rand()
    z1[:,:,2] = np.random.rand()

    z2 = np.ones((10,10,3))
    z2[:,:,0] = np.random.rand()
    z2[:,:,1] = np.random.rand()
    z2[:,:,2] = np.random.rand()

    zavg = (z1+z2)/2

    z1a = (z1+zavg)/2
    z2a = (z2+zavg)/2

    z3 = np.hstack((z1,z1a,zavg,z2a,z2))

    plt.imshow(z3);
    plt.show()



import numpy as np
import matplotlib.pyplot as plt

def recursive_average(colors):
    """
    Compute the recursive average of the given list of colors.

    Parameters:
    - colors: List of color arrays

    Returns:
    - A new list of color arrays containing the recursive averages.
    """
    new_colors = [colors[0]]
    for i in range(1, len(colors)):
        avg_color = (colors[i] + new_colors[-1]) / 2.0
        new_colors.extend([avg_color, colors[i]])
    return new_colors

def generate_recursive_colors_v2(passes):
    """
    Generate a visualization of 2 random colors and their recursive averages for a number of passes.

    Parameters:
    - passes: Number of times to apply the recursive averaging process

    Returns:
    - An image showing the 2 endpoint colors and their recursive averages.
    """
    # Start with 2 random colors
    colors = [np.ones((10,10,3)) for _ in range(2)]
    for color in colors:
        color[:,:,0] = np.random.rand()
        color[:,:,1] = np.random.rand()
        color[:,:,2] = np.random.rand()

    # Apply the recursive averaging for the specified number of passes
    for _ in range(passes):
        colors = recursive_average(colors)

    # Horizontally stack the colors
    result = np.hstack(colors)

    return result

for i in range(5):
    img = generate_recursive_colors_v2(i)
    plt.imshow(img)
    plt.axis('off')
    plt.tight_layout()
    plt.show()

import numpy as np
import matplotlib.pyplot as plt

def recursive_average(colors): #this function generates recursive color patterns

    new_colors = [colors[0]]
    for i in range(1, len(colors)):
        avg_color = (colors[i] + new_colors[-1]) / 2.0
        new_colors.extend([avg_color, colors[i]])
    return new_colors #extends the original colors with each pass, creating a gradient-like effect between the two colors

def generate_recursive_colors_v2(passes, initial_colors):

    colors = initial_colors.copy()

    for _ in range(passes):
        colors = recursive_average(colors)

    result = np.hstack(colors)

    return result

initial_colors = [np.ones((10, 10, 3)) for _ in range(2)] #random initial colors
for color in initial_colors:
    color[:,:,0] = np.random.rand()
    color[:,:,1] = np.random.rand()
    color[:,:,2] = np.random.rand()

passes_values = [0,1,2,3,4] #increases complexity for each pass
imgs = [generate_recursive_colors_v2(p, initial_colors) for p in passes_values]

fig, axs = plt.subplots(1, len(passes_values), figsize=(15, 5))

for ax, img, p in zip(axs, imgs, passes_values):
    ax.imshow(img)
    ax.axis('off')
    ax.set_title(f'Passes={p}')

plt.tight_layout()
plt.show()

"""https://lospec.com/palette-list"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
import matplotlib
import imageio.v2 as imageio
from PIL import Image

def get_colors_lospec(url):
    im = imageio.imread(url) #reads an image
    rgb_list = (im/255)[0,:,0:3] #extracts its RGB colors
    float_list = list(np.linspace(0,1,len(rgb_list)))
    cdict = dict() #creates a color dictionary
    for num, col in enumerate(['red', 'green', 'blue']):
        col_list = [[float_list[i], rgb_list[i][num], rgb_list[i][num]] for i in range(len(float_list))]
        cdict[col] = col_list
    cmp = mcolors.LinearSegmentedColormap('my_cmp', segmentdata=cdict, N=256) #generates a colormap
    return cmp

url = 'https://lospec.com/palette-list/agb-32x.png'
im = imageio.imread(url)
plt.imshow(im);

url = 'https://lospec.com/palette-list/agb-1x.png'
im = imageio.imread(url)
plt.imshow(im);

url = 'https://lospec.com/palette-list/moondrom-1x.png'
im = imageio.imread(url)
plt.imshow(im);

z = np.random.randint(0,255,size=(10,10)) #create a random integer array (10x10)

z

plt.imshow(z,cmap='jet') #shows the color map of z using the jet colormap

plt.imshow(z, cmap=get_colors_lospec(url)) #plots z using the get_colors_lospec(url) colormap
plt.colorbar();

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]
z = np.sqrt(x**2 + y**2) #function z=sqrt(x^2+y^2)

x

y

z = np.sqrt(x**2 + y**2)

z.shape

plt.imshow(x) #plots x values

plt.imshow(y) #plots y values

z

plt.imshow(z, cmap=get_colors_lospec(url)); #shows the gradient descent of z, with the colormap
plt.show()



x, y = np.mgrid[-5:5:0.05, -5:5:0.05] #shows z=sin(3y) over [-5,5] with a step of 0.05

z = np.sin(3*y)

plt.imshow(z, cmap=get_colors_lospec(url)); #plots with colormap
plt.show()

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]  #shows z=sin(3x) over [-5,5] with a step of 0.05

z = np.sin(3*x)

plt.imshow(z, cmap=get_colors_lospec(url)); #plots with colormap
plt.show()

x, y = np.mgrid[-5:5:0.05, -5:5:0.05]  #shows the composition of the last 2 functions over [-5,5] with a step of 0.05

z = np.sin(3*y)*np.sin(3*x)

plt.imshow(z, cmap=get_colors_lospec(url)); #plots with colormap
plt.show()



import matplotlib.pyplot as plt
import imageio
from PIL import Image
from skimage.io import imread

def plot(x): #defines a function plot that will plot multiple images
    fig, ax = plt.subplots()
    im = ax.imshow(x,cmap='gray')
    ax.axis('off')
    fig.set_size_inches(20, 20)
    plt.show()

im = imread('https://raw.githubusercontent.com/imageio/imageio-binaries/master/images/imageio_banner.png')

plot(im) #plots the given images that are stored from the previous line

url = "https://upload.wikimedia.org/wikipedia/commons/thumb/5/57/Octopus2.jpg/800px-Octopus2.jpg"

im = imread(url)

plot(im) #plots a new image

im.shape #tells the dimensions of the image

plt.imshow(im[:,:,0],cmap="gray") #uses the gray colormap to put the image in grayscale, only takes elements from the first color channel

plt.imshow(im[:,:,1],cmap="gray") #uses the gray colormap to put the image in grayscale, only takes elements from the second color channel

plt.imshow(im[:,:,2],cmap="gray") #uses the gray colormap to put the image in grayscale, only takes elements from the third color channel

r = im[:,:,0]
g = im[:,:,1]
b = im[:,:,2]

combo = np.hstack([r,g,b])

plt.imshow(combo,cmap="gray") #stacks the elements to compare RvGvB

