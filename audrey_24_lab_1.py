# -*- coding: utf-8 -*-
"""Audrey_24 Lab 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1zXRWRQOOHDjG2hGhIw16WeZK2wOV_rH7

## Python Basics

### Calculator
"""

# Comments with hashtag, python ignores this

30.34321 + 9.12313 - 3.5567 #addition and subtraction

2*2 #multiplication

2**8 #powers (** not ^)

2**123

2**12345

import sys
sys.set_int_max_str_digits(100000) #allows for the string to exceed the previous maximum digits
2**45678

8/4 #division

8//4 #quotient

8%12 #remainder (modular arithmetic)

13%12

22%12

24%12 #24(mod 12)=0

"""### Variables"""

apples = 5 #naming variables and assigning them quanities

oranges = 8

total = apples + oranges #variable addition

total #printing the total apples and oranges

apples**2 #variable powers

cost_per_apple = 0.25

total_apple_costs = cost_per_apple * apples #variable multiplication

total_apple_costs #printing the total apple cost

"""### Vectors"""

import numpy as np
import matplotlib.pyplot as plt #importing numpy functions and plotting

np.arange(10) #create an array

x = np.arange(10);x #added semicolon to recall stored variable instead of new line

x[4] #shows element 4 of the array

y = 3 * x + 5 #creating an array that follows the function, ie. x=0 y=5

y

# x = np.array([133,24,333,4,5,6])
# y = np.array([11,22,33,44,55,66])

x,y #displays both arrays

"""### Plotting"""

plt.plot(x,y) #graph lines

plt.plot(x,y,'.') #dotted line

plt.plot(x,y,'r.') #color_change dotted

plt.plot(x,y,'b--') #color_change dashed

import matplotlib.pyplot as plt #import libraries

plt.plot(x,y)

x = np.linspace(0,5,10);x #randomized array

x

y = x**2;y #added semicolon for recall

plt.plot(x,y) #graph of y=x^2

plt.plot(x,y) #insert title and axis labels
plt.title("New Graph of x**2");
plt.xlabel("x");
plt.ylabel("y");

plt.plot(x,y,label="x squared") #added line labels
plt.title("Graph of x**2");
plt.xlabel("x");
plt.ylabel("y");
plt.legend()

x = np.linspace(0, 2, 100) #insert multiple lines

plt.plot(x, x, label='linear')
plt.plot(x, x**2, label='quadratic')
plt.plot(x, x**3, label='cubic')

plt.xlabel('x label')
plt.ylabel('y label')

plt.title("Simple Plot")

plt.legend()

labels = 'Frogs', 'Dogs', 'Cats', 'Birds' #pie charts
sizes = [15, 30, 40, 15]
explode = (0, 0.1, 0, 0)  # only "explode" the 2nd slice (i.e. 'Dogs')

fig1, ax1 = plt.subplots()
ax1.pie(sizes, explode=explode, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)
ax1.axis('equal')  # Equal aspect ratio ensures that pie is drawn as a circle.
plt.show()

import numpy as np #graph of sine function
import matplotlib.pyplot as plt
t = np.arange(0.0, 2.0, 0.01)
s = np.sin(2*np.pi*t)

plt.plot(t, s)
plt.title(r'$\alpha_i > \beta_i$', fontsize=20)
plt.text(1, -0.6, r'$\sum_{i=0}^\infty x_i$', fontsize=20)
plt.text(0.5, 0.6, r'$\mathcal{A}\mathrm{sin}(2 \omega t)$',fontsize=15)
plt.xlabel('time (s)')
plt.ylabel('volts (mV)')
plt.show()

"""Plot the following functions from $x = -10$ to $x = 10$

(Hint: np.sin, np.exp)

$y = 10x+7$

$y = -3x-12$

$y=\sin(x)$

$y=e^x$

$y=e^{-x^2}$
"""

import numpy as np #exercise
import matplotlib.pyplot as plt

x = np.linspace(-10, 10, 100)  #-10 to 10, 100 points

plt.plot(x, 10*x+7, label='10x+7') #all graphs
plt.plot(x, -3*x-12, label='-3x-12')
plt.plot(x, np.sin(x), label='sin(x)')
plt.plot(x, np.exp(x),  label='exp(x)')
plt.plot(x, np.exp(-(x**2)),  label='exp(-(x**2))')

plt.xlabel('x label') #labeling the axis
plt.ylabel('y label')

plt.title("Simple Plot") #adding a title

plt.ylim(-3, 3) #set y-axis limits

plt.legend() #displaying the legend

plt.show() #show the plot

"""Pick out a plot of your choice from [here](https://matplotlib.org/stable/gallery/index.html), copy the code to this notebook, run, and document to the best of your abilities."""

import matplotlib.pyplot as plt
import numpy as np

x = np.linspace(-np.pi/2, np.pi/2, 31)
y = np.cos(x)**3 #function that will be applied

# 1) remove points where y > 0.7 (update arrays)
x2 = x[y <= 0.7]
y2 = y[y <= 0.7]

# 2) mask points where y > 0.7
y3 = np.ma.masked_where(y > 0.7, y) #masked values not used in plots and calculations (ommited)

# 3) set to NaN where y > 0.7
y4 = y.copy() #copy of the y array
y4[y3 > 0.7] = np.nan #numbers that do not exist (wouldn't have been taken)

plt.plot(x*0.1, y, 'o-', color='lightgrey', label='No mask') #plots all values correspondingly, even the ones that wouldn't have been plotted
plt.plot(x2*0.4, y2, 'o-', label='Points removed')
plt.plot(x*0.7, y3, 'o-', label='Masked values')
plt.plot(x*1.0, y4, 'o-', label='NaN values')
plt.legend()
plt.title('Masked and NaN data')
plt.show()

import matplotlib.pyplot as plt
import numpy as np

from matplotlib.colors import Normalize
from matplotlib.markers import MarkerStyle
from matplotlib.text import TextPath
from matplotlib.transforms import Affine2D

SUCCESS_SYMBOLS = [
    TextPath((0, 0), "â˜¹"),
    TextPath((0, 0), "ðŸ˜’"),
    TextPath((0, 0), "â˜º"),
]

N = 25 #times thrown
skills = np.random.uniform(5, 80, size=N) * 0.1 + 5
takeoff_angles = np.random.normal(0, 90, N)
thrusts = np.random.uniform(size=N)
successful = np.random.randint(0, 3, size=N)
positions = np.random.normal(size=(N, 2)) * 5
data = zip(skills, takeoff_angles, thrusts, successful, positions) #descriptions of each throw

cmap = plt.colormaps["jet"]
fig, ax = plt.subplots() #plotting
fig.suptitle("Throwing success", size=14)
for skill, takeoff, thrust, mood, pos in data:
    t = Affine2D().scale(skill).rotate_deg(takeoff) #rotates the data depending on skill and takeoff
    m = MarkerStyle(SUCCESS_SYMBOLS[mood], transform=t) #assigns a success symbol to each marker that is based off of the mood and applies t to it
    ax.plot(pos[0], pos[1], marker=m, color=cmap(thrust)) #plotting all values with a marker and a color based off of the thrust value


plt.show() #alters the smiley faces mood depending on ones throwing capability







"""### Graphics Output"""

from IPython.core.display import display, HTML #allows us to display images later

display(HTML('<h1>Hello World!</h1>'))

"""### Numpy - Numerical Python"""

import numpy as np

help(np) #lists all commands for numpy & their uses

help(np.dot) #understanding dot product function in numpy

"""Example"""

u=np.array([(1,2,-1)]);u #create array u

v=np.array([0,-3,2]);v #create array v

print(u,v) #recall variable

np.dot(u,v) #dot_product

np.random.random() #'random' number generation

np.random.random() > 0.5;

r=np.random.random(); print(r); r>0.5 #generate and check if the number is greater than 0.5

r

r > 0.5







def flip_coin(): #algorithm to 'flip' a coin
    if np.random.random() > 0.5:
        print("Heads")
    else:
        print("Tails")

flip_coin() #executes program

np.random.randint(15,20)

def coin():
  return np.random.randint(2)

coin()

display(HTML('<img src="https://random-ize.com/coin-flip/us-quarter/us-quarter-front.jpg">')) #displays a coin image

heads = 'https://random-ize.com/coin-flip/us-quarter/us-quarter-front.jpg' #assigns the appropriate images to their variables
tails = 'https://random-ize.com/coin-flip/us-quarter/us-quarter-back.jpg'

def show_img(img):
  display(HTML('<img src=' + img + '>')) #function to recall the image

show_img(heads)

show_img(tails)

def flip_coin(): #adds another function which recalls our previous one and displays its corresponding image

    if coin():
        show_img(heads)
    else:
        show_img(tails)

flip_coin()

for i in range(5):
    flip_coin() #flips coin 5 times





"""# Cards"""



card_url_head = "https://www.improvemagic.com/wp-content/uploads/2020/11/"
card_url_tail = ".png" #creates variables showing images of cards

suit = ['k','p','s','l'] #clubs,spades,hearts,diamonds
card = ['a','2','3','4','5','6','7','8','9','10','j','q','k'] #assigns values to individual cards

i = np.random.randint(4)
j = np.random.randint(13)

i,j #shows a pair of random numbers

suit[i] #finds representing value in suit array

card[j] #shows which card was pulled for j

def card_image(card_number):

    i = card_number//13
    j = card_number%13

    return suit[i]+card[j]

card_image(3)

img = card_url_head + card_image(3) + card_url_tail

img

show_img(img)

for i in range(52):
    img = card_url_head + card_image(i) + card_url_tail
    show_img(img)

import random

def initialize_deck():
    #Create and shuffle a deck of 52 cards represented by numbers 0-51.
    deck = list(range(52))
    random.shuffle(deck)
    return deck

def draw_cards(deck, top_index, num=5):
    drawn_cards = deck[top_index:top_index + num]
    return drawn_cards, top_index + num

# Initialize and shuffle the deck
deck = initialize_deck()
top_index = 0  # Start at the beginning of the deck

deck

# Draw 5 cards for a poker hand
hand, top_index = draw_cards(deck, top_index, 5)

hand

hand, top_index = draw_cards(deck, top_index, 5) #draws 5 cards

hand #displays the hand values

# Display the hand
for card_number in hand:
    img_url = card_url_head + card_image(card_number) + card_url_tail
    show_img(img_url)

def show_hand(hand):
    images_html = ''.join([f'<img src="{card_url_head + card_image(card_number) + card_url_tail}" style="display:inline-block; margin:5px;" />' for card_number in hand])
    display(HTML(images_html))

show_hand(hand) #shows images of the cards in hand





"""# Rank Hand"""

def evaluate_hand(hand):
    rank_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9, '10': 10, 'j': 11, 'q': 12, 'k': 13, 'a': 14}
    suits = ['k', 'p', 's', 'l']  # clubs, spades, hearts, diamonds

    # Convert the hand to a list of (rank, suit) tuples
    converted_hand = [(rank_values[card[card_number % 13]], suits[card_number // 13]) for card_number in hand]
    converted_hand.sort()

    rank_counts = {rank: 0 for rank in rank_values.values()}
    suit_counts = {suit: 0 for suit in suits}
    for rank, suit in converted_hand:
        rank_counts[rank] += 1
        suit_counts[suit] += 1

    # Check for flush
    is_flush = max(suit_counts.values()) == 5

    # Check for straight and royal flush
    rank_sequence = [rank for rank, _ in converted_hand]
    is_straight = all(rank_sequence[i] - rank_sequence[i - 1] == 1 for i in range(1, 5))
    is_royal = is_straight and rank_sequence[0] == 10

    # Check for other hand types
    pairs = sum(1 for count in rank_counts.values() if count == 2)
    three_of_a_kind = 3 in rank_counts.values()
    four_of_a_kind = 4 in rank_counts.values()

    if is_royal and is_flush:
        return "Royal Flush"
    elif is_straight and is_flush:
        return "Straight Flush"
    elif four_of_a_kind:
        return "Four of a Kind"
    elif three_of_a_kind and pairs == 1:
        return "Full House"
    elif is_flush:
        return "Flush"
    elif is_straight:
        return "Straight"
    elif three_of_a_kind:
        return "Three of a Kind"
    elif pairs == 2:
        return "Two Pair"
    elif pairs == 1:
        return "One Pair"
    else:
        return "High Card" #classifies and looks for hands by rank



# Initialize and shuffle the deck
deck = initialize_deck()
top_index = 0  # Start at the beginning of the deck

hand, top_index = draw_cards(deck, top_index, 5)


print(evaluate_hand(hand))
show_hand(hand)

# took me about 60 attempts for 3 of a kind, never got a royal flush (it was taking a while)

for i in range(10):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)


    print(evaluate_hand(hand))
    show_hand(hand)



for i in range(100):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Two Pair":
        print("Winner!")
        show_hand(hand) #looks for all 2 pair wins



for i in range(1000):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Flush":
        print("Winner!")
        show_hand(hand) #looks for all flush wins

# Commented out IPython magic to ensure Python compatibility.
# %%timeit
# # Initialize and shuffle the deck
# deck = initialize_deck()
# top_index = 0  # Start at the beginning of the deck
# 
# hand, top_index = draw_cards(deck, top_index, 5)
# 
# if evaluate_hand(hand) == "Royal Flush":
#     print("Winner!")
#     show_hand(hand)

for i in range(1000000):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Royal Flush":
        print("Winner!")
        show_hand(hand) #iterates until a royal flush is found



wins = 0
N = 10000000

for i in range(N):
    # Initialize and shuffle the deck
    deck = initialize_deck()
    top_index = 0  # Start at the beginning of the deck

    hand, top_index = draw_cards(deck, top_index, 5)

    if evaluate_hand(hand) == "Royal Flush":
        wins += 1
        print("Winner!")
        show_hand(hand) #all royal flush wins: 18

wins/N

