# -*- coding: utf-8 -*-
"""Audrey_24 Lab 7 Lab Convolution and PDE.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ZpF6iTjwbIA7qdSfdGcEG-_WM4ufV_yt

Never Say Never - Documentary on Belousovâ€“Zhabotinsky Reaction BZ

https://www.youtube.com/watch?v=FvXwVZPOoBI


Image Kernels Explained Visually

https://setosa.io/ev/image-kernels/
"""

import numpy as np
from skimage import io as io
import matplotlib.pyplot as plt
from scipy import signal
import torch.nn.functional as F
from torch.nn.functional import *
import torch
import torch.nn as nn
import torchvision
import torchvision.transforms as transforms
import time
from matplotlib import animation, rc
from IPython.display import HTML
rc('animation', html='html5')

def make_ani(A, colormap='gray'):

    fig, ax = plt.subplots()
    im = ax.imshow(A[0,:,:], cmap = colormap);
    ax.axis('off')
    fig.set_size_inches(12, 12)

    def animate(data, im):
        im.set_data(data)

    def step():
        for i in range(A.shape[0]):
            data = A[i,:,:]
            yield data

    return animation.FuncAnimation(fig, animate, step, interval=100, repeat=True, fargs=(im,))

def plot(x):
    fig, ax = plt.subplots()
    im = ax.imshow(x, cmap = 'gray')
    ax.axis('off')
    fig.set_size_inches(15, 15)
    plt.show()

image = io.imread("https://www.filfre.net/wp-content/uploads/2013/12/bbc4.png")

image.shape #RGBa

plot(image)

image.shape #512x640, Colors

plot(image[:,:,0]) #filter black and white

plot(image[:,:,1])

plot(image[:,:,2])

image.shape

image = np.mean(image, axis=2) #assign the image to a variable

plot(image)

image.shape

a = np.matrix([[1,2,1],[0,0,0],[-1,-2,-1]]) #take the top sobel

a #transformation filter matrix

plot(a) #plots the top sobel matrix (filter)

image.shape #loses color

y = signal.convolve2d(image, a, mode='same') #image affected by matrix a

plot(y) #grayed out, loses vertical lines

a = np.transpose(a) #takes the transpose of the matrix, left sobel

a #recalls the left sobel

plot(a) #left-light -> right-dark

y = signal.convolve2d(image, a, mode='same') #take the left sobel of the image

plot(y)

b = np.random.random((25,25)) #randomized to create blur effect

y = signal.convolve2d(image, b) #apply the matrix to the image

plot(y) #plot the new image

x = io.imread("https://ichef.bbci.co.uk/news/660/cpsprodpb/C342/production/_88068994_thinkstockphotos-493881770.jpg")
x = x[:,:,0]

x = x.astype(float)

x

x = x / 255.0
plot(x)

x

a

a[1,1]

def conv2(x,f): #sliding formula, corresponds spots in the matrix to appropriate boxes in the 3x3 square
    x2 = np.zeros(x.shape)
    for i in range(1,x.shape[0]-1):
        for j in range(1,x.shape[1]-1):

            x2[i,j] = f[0,0] * x[i-1,j-1]  \
            +         f[0,1] * x[i-1,j]    \
            +         f[0,2] * x[i-1,j+1]  \
            +         f[1,0] * x[i,j-1]    \
            +         f[1,1] * x[i,j]      \
            +         f[1,2] * x[i,j+1]    \
            +         f[2,0] * x[i+1,j-1]  \
            +         f[2,1] * x[i+1,j]    \
            +         f[2,2] * x[i+1,j+1]

    return x2

a = np.matrix([[-1,-1,-1],[-1,8,-1],[-1,-1,-1]])
# a = np.matrix([[1,2,1],[0,0,0],[-1,-2,-1]])
# a = np.matrix([[1,1,1],[1,1,1],[1,1,1]])
# a = 5*np.random.random((3,3))-5*np.random.random((3,3))

a

z = conv2(x,a)

plot(z)

for i in range(10): #machine learning, filters to self-driving vehicles
    a = 2*np.random.random((3,3))-1
    print(a)
    z=conv2(x,a)
    plot(z)



#Homemade Conv Loop Timing
a = 2*np.random.random((9,3,3))-1
start_time = time.time()
for i in range(9):

    z=conv2(x,a[i,:,:])

print("Seconds:", (time.time() - start_time))

#Optimized Code Timing
a = 2*np.random.random((9,3,3))-1
start_time = time.time()
for i in range(9):

    z = signal.convolve2d(x,a[i,:,:])

print("--- %s seconds ---" % (time.time() - start_time))

#GPU Processing Timing, No Loop, 96 filters!!
a2 = 2*np.random.random((96,1,3,3))-1
x2 = torch.tensor(x).cuda()
a2 = torch.tensor(a2).cuda()
x2 = x2[None,None,:,:]

start_time = time.time()
z = conv2d(x2,a2)
print("--- %s seconds ---" % (time.time() - start_time))

z.shape



image = io.imread("https://img.jagranjosh.com/imported/images/E/Articles/Fastest-Fish-img.jpg").astype(float)/255.0
plot(image) #color image, filter has to have as many color channels as the input

image.shape

plot(np.random.random((11,11,3))) #random filter

image = np.transpose(image, (2, 0, 1))

image.shape

f = np.random.random((1,3,11,11))

image.shape

image = image[None,:,:,:]

image.shape,f.shape

f =  torch.tensor(f)
image =  torch.tensor(image)

image2 = F.conv2d(image,f)

image2 = image2.numpy()

image2.shape

image2[0,0,:,:].shape

plot(image2[0,0,:,:]) #feature map is always in black and white, loses color and becomes blurry because of randomized #s



image = io.imread("http://ian-albert.com/games/super_mario_bros_maps/mario-2-2.gif")
image = image[:,0:700,:]
plot(image)

coin = image[185:200,224:239,:]

plot(coin)

image = image[60:,0:700,:]
plot(image)

def scale1(x):
    return (x-np.min(x))/(np.max(x)-np.min(x))

image = np.mean(image,axis=2)
coin = np.mean(coin,axis=2)

image = scale1(image)
coin = scale1(coin)

plot(image)
plot(coin) #black and white for simplicity

coin.shape #15x15 pixels

image = image - np.mean(image)
coin = coin - np.mean(coin) #normalizing values

image.shape,coin.shape

coin = np.rot90(coin, 2)

plot(coin)

z = signal.convolve2d(image,coin) #looking for a coin in the image, comparing where it matches the most and store in z (feature map)

# z = conv2(image,coin) #convolution operation essentially searches for the given input image inside the new provided image

plot(z) #the few bright hotspots are coins (matches) #input * feature = feature map

z == np.max(z) #checking for the maximum (brightest points)

plot(z==np.max(z)) #plot the brightest points (coins)

np.where(z == np.amax(z)) #checking/find the locations of the brightest points (coins)

[y,x] = np.where(z == np.amax(z))

plt.plot(x,-y,'.')

fig, ax = plt.subplots() #coin detector
im = ax.imshow(image, cmap = 'gray')
ax.axis('off')
ax.scatter(x-6, y-6, c='red', s=40)
fig.set_size_inches(18, 10)

#class notes:
#tensor space, input image, 6 filters to 'throw' away pixels until we get 1 number between 0 and 9

#pooling, take the highest value in a block and make it the new output in new box (gets blockier, lower res in feature map)

#repeating operations until final result

#alexnet, shows color channels (filter)> yellow images (pooling)> blue images (shrunk down versions of yellow)>repeat

#report if the filters are seen in the input image. normalize, scales all feature maps to the same brightness

#filters have to match the same depth as the image > feature map (once all computed can combine in stacks to make a new 'loaf')

def conv2(w,f): #GPU conv with padding

    n = conv2d(w.type(torch.int),f.type(torch.int))
    n = pad(n, (1, 1, 1, 1)) #add ones to the sides of the matrix

    return n

#Game of Life

w = (np.random.random((100,100)) > 0.5) #game of life world grid w
f = np.matrix([[1,1,1],[1,0,1],[1,1,1]])

f

plot(w) #QR code

steps = 1000
A = torch.zeros((steps,100,100)) # storage for frames for animation
w = torch.tensor(w.astype(int))[None,None,:,:]
f = torch.tensor(f.astype(int))[None,None,:,:]

# %%timeit
n = conv2(w,f)

# (n==2)[0,0,:,:].shape

plot((n==2)[0,0,:,:])

for i in range(steps):

    n = conv2(w,f)

    w = (w * (n==2)) + (n==3)

    A[i] = w

make_ani(A)







#Surface Tension Model

w = (np.random.random((100,100)) > 0.5).astype(int)
f = np.matrix([[1,1,1],[1,1,1],[1,1,1]])

steps = 200
A = torch.zeros((steps,100,100)) # storage for frames for animation
w = torch.tensor(w)[None,None,:,:]
f = torch.tensor(f)[None,None,:,:]

for i in range(steps):

    n = conv2(w,f)

    w = ~((n<4) + (n==5))

    A[i] = w

make_ani(A)



#Forest Fire Model

# veg = {empty=0 burning=1 green=2}

#set the probability of lightning and growth
Plightning = 0.00005
Pgrowth = 0.01

#create a 100x100 matrix w with random 0s and 1s
w = (np.random.random((100,100)) > 0.5).astype(int)

#define a 3x3 matrix f which might be used as a filter or kernel for convolution
f = np.matrix([[1,1,1],[1,0,1],[1,1,1]])

#set the number of steps for the simulation
steps = 1000

#initialize a 3D tensor A with zeros. This will be used to store the state of w at each step of the simulation
A = torch.zeros((steps,100,100))

#convert w and f to PyTorch tensors. The [None,None,:,:] indexing adds two extra dimensions, making w and f 4D tensors
w = torch.tensor(w)[None,None,:,:]
f = torch.tensor(f)[None,None,:,:]

for i in range(steps):  #loop for a certain number of steps

    n = w == 1  #create a new matrix n where 'True' corresponds to 1 in w and false elsewhere

    n = conv2(n,f)  #apply a 2D convolution to n using the kernel f

    w =  2*((w == 2)).type(torch.int)  #set elements of w that are equal to 2 to 2
    w -= 1*((w == 2) * ( n > 0 ) ).type(torch.int)  #subtract 1 from elements of w that are equal to 2 and where the corresponding element of n is greater than 0
    w -= 1*((w == 2) * ( np.random.random((100,100)) < Plightning)).type(torch.int)  #subtract 1 from elements of w that are equal to 2 and where a random number is less than Plightning
    w += 2*((w == 0) * ( np.random.random((100,100)) < Pgrowth)).type(torch.int)  #add 2 to elements of w that are equal to 0 and where a random number is less than Pgrowth

    A[i] = w  #store the current state of w in the i-th element of A

make_ani(A, colormap='magma')





#Nonlinear Waves

w = np.random.random((100,100)) < 0.1
f = np.matrix([[1,1,1],[1,0,1],[1,1,1]])

t  = 6  #center value=6; 7 makes fast pattern; 5 analiating waves
t1 = 3  #center value=3

steps = 1000
A = torch.zeros((steps,100,100)) # storage for frames for animation
w = torch.from_numpy(w)[None,None,:,:]
f = torch.from_numpy(f)[None,None,:,:]

for i in range(1000): #loop 1000 times

    n = (w>0)&(w<t) #create a new matrix n where 'True' corresponds to elements in w that are greater than 0 and less than t

    n = conv2(n,f) #apply 2D convulution to n using the kernel f

    w = ((w==0) & (n>=t1)) \ #set elements of w that are equal to 0 and where the corresponding element of n is greater than or equal to t1 to 1
    +  2*(w==1)            \ #1->2
    +  3*(w==2)            \ #2->3
    +  4*(w==3)            \ #3->4
    +  5*(w==4)            \ #4->5
    +  6*(w==5)            \ #5->6
    +  7*(w==6)            \ #6->7
    +  8*(w==7)            \ #7->8
    +  9*(w==8)            \ #8->9
    +  0*(w==9)            \ #9->0

    A[i] = w #store the current state of w in the i-th element of A

make_ani(A)





#Wireword Wire
#{empty=0 electron_head=1 electron_tail=2, wire=3}

w = np.zeros((100,100))  #create a 100x100 matrix w filled with zeros
w[50,:] = 3  #set all elements in the 51st row of w to 3
w[50,5] = 2  #set the 6th element in the 51st row of w to 2
w[50,6] = 1  #set the 7th element in the 51st row of w to 1

f = np.matrix([[1,1,1],[1,0,1],[1,1,1]])  #define a 3x3 matrix f which might be used as a kernel for convolution

steps = 1000  # Set the number of steps for the simulation

A = torch.zeros((steps,100,100))  #initialize a 3D tensor A with zeros. This will be used to store the state of w at each step of the simulation

w = torch.from_numpy(w)[None,None,:,:]  #convert w from a NumPy array to a PyTorch tensor and add two extra dimensions, making w a 4D tensor
f = torch.from_numpy(f)[None,None,:,:]  #convert f from a NumPy array to a PyTorch tensor and add two extra dimensions, making f a 4D tensor

for i in range(100):  #loop 100 times

    n = w == 1  #create a new matrix n where 'True' corresponds to elements in w that are equal to 1

    n = conv2(n, f)  #apply a 2D convolution to n using the kernel f

    w = 1 * ((w == 3) & ((n == 1) | (n == 2))) \  #set elements of w that are equal to 3 and where the corresponding element of n is either 1 or 2 to 1
    + 3 * ((w == 3) & ((n != 1) & (n != 2))) \  #set elements of w that are equal to 3 and where the corresponding element of n is neither 1 nor 2 to 3
    + 0 * (w == 0) \  #0->0
    + 2 * (w == 1) \  #1->2
    + 3 * (w == 2)    #2->3

    A[i] = w  #store the current state of w in the i-th element of A

make_ani(A, colormap='magma')



#Wireworld Oscillator

w = np.zeros((100,100))  # Create a 100x100 matrix w filled with zeros
w[50,15:-1] = 3  #set elements from the 16th to the last in the 51st row of w to 3
w[48,5:15] = 3  #set elements from the 6th to the 15th in the 49th row of w to 3
w[52,5:15] = 3  #set elements from the 6th to the 15th in the 53rd row of w to 3
w[49:52,4] = 3  #set elements in the 5th column from the 50th to the 52nd row of w to 3
w[49:52,15] = 3  #set elements in the 16th column from the 50th to the 52nd row of w to 3
w[52,14] = 1  #set the 15th element in the 53rd row of w to 1
w[52,13] = 2  #set the 14th element in the 53rd row of w to 2

f = np.matrix([[1,1,1],[1,0,1],[1,1,1]])  #define a 3x3 matrix f which might be used as a kernel for convolution

steps = 1000  #set the number of steps for the simulation

A = torch.zeros((steps,100,100))  #initialize a 3D tensor A with zeros. This will be used to store the state of w at each step of the simulation

w = torch.from_numpy(w)[None,None,:,:]  # Convert w from a NumPy array to a PyTorch tensor and add two extra dimensions, making w a 4D tensor
f = torch.from_numpy(f)[None,None,:,:]  # Convert f from a NumPy array to a PyTorch tensor and add two extra dimensions, making f a 4D tensor

for i in range(steps):  #loop for a certain number of steps

    n = w == 1  #create a new matrix n where 'True' corresponds to elements in w that are equal to 1

    n = conv2(n, f)  #apply a 2D convolution to n using the kernel f

  w = 0 * (w == 0) \  #0->0
    + 2 * (w == 1) \  #1->2
    + 3 * (w == 2) \  #2->3
    + 3 * ((w == 3) & ((n != 1) & (n != 2))) \  #set elements of w that are equal to 3 and where the corresponding element of n is neither 1 nor 2 to 3
    + 1 * ((w == 3) & ((n == 1) | (n == 2)))  #set elements of w that are equal to 3 and where the corresponding element of n is either 1 or 2 to 1

    A[i] = w  #store the current state of w in the i-th element of A

make_ani(A, colormap='magma')





#FitzHugh-Nagumo Reaction Diffusion

def laplacian(U):
    n = conv2d(U,laplace)
    n = pad(n, (1, 1, 1, 1),'circular')
    return n

laplace = 0.5*np.array([[0.5, 1.0, 0.5],
                        [1.0, -6., 1.0],
                        [0.5, 1.0, 0.5]])

N = 256  #define the size of the matrices
h = 0.05  #define a variable h

A = np.zeros([N, N], dtype=np.float32)  #create a NxN matrix A filled with zeros of type float32

A = A + -0.7  #subtract 0.7 from all elements in A

noise_shape = A[:,120:130].shape  #get the shape of a slice of A from column 121 to 130

A[:,120:130] = (np.random.normal(0.9,0.05,size=noise_shape))  #replace the slice of A from column 121 to 130 with random numbers drawn from a normal distribution with mean 0.9 and standard deviation 0.05

B = np.zeros([N, N], dtype=np.float32)  #create a NxN matrix B filled with zeros of type float32

B = B + -0.3  #subtract 0.3 from all elements in B

w1 = plot(A)

a0 = -0.1
a1 = 2
epsilon = 0.05
delta = 4
k1 = 1
k2 = 0
k3 = 1

A = torch.from_numpy(A)[None,None,:,:].cuda()
B = torch.from_numpy(B)[None,None,:,:].cuda()
laplace = torch.from_numpy(laplace)[None,None,:,:].type(torch.float).cuda()

steps = 100
P = torch.zeros((steps,N,N)) # storage for frames for animation

j = 0  #initialize a counter variable 'j'

#loop for a certain number of steps, each step is multiplied by 1000
for i in range(steps*1000):

    #update the matrix A based on a formula that includes its current state, the state of B, and the Laplacian of A
    A += h*( k1*A - k2*A**2 - A**3 - B + laplacian(A))

    #update the matrix B based on a formula that includes its current state, the state of A, and the Laplacian of B
    B += h*( epsilon*(k3*A - a1*B -a0) + delta*laplacian(B) )

    #every 1000 steps, store the current state of A in the j-th element of P and increment j
    if i % 1000 == 0:
        P[j] = A
        j += 1

make_ani(P)



#Gray Scott Reaction Diffusion

laplace = 0.5*np.array([[0.5, 1.0, 0.5],
                        [1.0, -6., 1.0],
                        [0.5, 1.0, 0.5]])

laplace = torch.from_numpy(laplace)[None,None,:,:].type(torch.float).cuda()

def laplacian(U):
    n = conv2d(U,laplace)
    n = pad(n, (1,1,1,1))
    n = pad(n, (0,0,0,0))
    return n

(Du, Dv, F, k) = ((0.16, 0.08, 0.035, 0.065)) # Bacteria 1
# (Du, Dv, F, k) = ((0.14, 0.06, 0.035, 0.065)) # Bacteria 2
# (Du, Dv, F, k) = ((0.16, 0.08, 0.060, 0.062)) # Coral
# (Du, Dv, F, k) = ((0.19, 0.05, 0.060, 0.062)) # Fingerprint
# (Du, Dv, F, k) = ((0.10, 0.10, 0.018, 0.050)) # Spirals
# (Du, Dv, F, k) = ((0.12, 0.08, 0.020, 0.050)) # Spirals Dense
# (Du, Dv, F, k) = ((0.10, 0.16, 0.020, 0.050)) # Spirals Fast
# (Du, Dv, F, k) = ((0.16, 0.08, 0.020, 0.055)) # Unstable
# (Du, Dv, F, k) = ((0.16, 0.08, 0.050, 0.065)) # Worms 1
# (Du, Dv, F, k) = ((0.16, 0.08, 0.054, 0.063)) # Worms 2
# (Du, Dv, F, k) = ((0.16, 0.08, 0.035, 0.060)) # Zebrafish

N = 256

U = np.zeros((N,N)) # Clear Chemicals
V = np.zeros((N,N))

U = U + 1.0
r = 5
U[N//2-r:N//2+r,N//2-r:N//2+r] = 0.50 # Add Disturbance in Center Square Radius r
V[N//2-r:N//2+r,N//2-r:N//2+r] = 0.25

U += 0.05*np.random.random((N,N)) # Add Noise to Chemicals
V += 0.05*np.random.random((N,N))

U = torch.from_numpy(U)[None,None,:,:].type(torch.float).cuda()
V = torch.from_numpy(V)[None,None,:,:].type(torch.float).cuda()

steps = 2000
skip = 100
P = torch.zeros((steps,N,N)) # storage for frames for animation

j = 0  #initialize a counter variable j

#loop for a certain number of steps, each step is multiplied by skip
for i in range(steps*skip):

    #update the matrix U based on a formula that includes its current state, the state of V, and the Laplacian of U
    U += ( Du*laplacian(U) - U*V**2 +  F   *(1-U) )

    #update the matrix V based on a formula that includes its current state, the state of U, and the Laplacian of V
    V += ( Dv*laplacian(V) + U*V**2 - (F+k)*V     )

    #every skip steps, store the current state of U in the j-th element of P and increment j
    if i % skip == 0:
        P[j] = U
        j += 1

make_ani(P)











# (Du, Dv, F, k) = ((0.16, 0.08, 0.035, 0.065)) # Bacteria 1
# (Du, Dv, F, k) = ((0.14, 0.06, 0.035, 0.065)) # Bacteria 2
# (Du, Dv, F, k) = ((0.16, 0.08, 0.060, 0.062)) # Coral
# (Du, Dv, F, k) = ((0.19, 0.05, 0.060, 0.062)) # Fingerprint
# (Du, Dv, F, k) = ((0.10, 0.10, 0.018, 0.050)) # Spirals
# (Du, Dv, F, k) = ((0.12, 0.08, 0.020, 0.050)) # Spirals Dense
# (Du, Dv, F, k) = ((0.10, 0.16, 0.020, 0.050)) # Spirals Fast
# (Du, Dv, F, k) = ((0.16, 0.08, 0.020, 0.055)) # Unstable
# (Du, Dv, F, k) = ((0.16, 0.08, 0.050, 0.065)) # Worms 1
# (Du, Dv, F, k) = ((0.16, 0.08, 0.054, 0.063)) # Worms 2
(Du, Dv, F, k) = ((0.16, 0.08, 0.035, 0.060)) # Zebrafish

N = 256

U = np.zeros((N,N)) # Clear Chemicals
V = np.zeros((N,N))

U = U + 1.0
r = 5
U[N//2-r:N//2+r,N//2-r:N//2+r] = 0.50 # Add Disturbance in Center Square Radius r
V[N//2-r:N//2+r,N//2-r:N//2+r] = 0.25

U += 0.05*np.random.random((N,N)) # Add Noise to Chemicals
V += 0.05*np.random.random((N,N))

U = torch.from_numpy(U)[None,None,:,:].type(torch.float).cuda()
V = torch.from_numpy(V)[None,None,:,:].type(torch.float).cuda()

steps = 2000
skip = 100
P = torch.zeros((steps,N,N)) # storage for frames for animation

j = 0 #same as before
for i in range(steps*skip):

    U += ( Du*laplacian(U) - U*V**2 +  F   *(1-U) )
    V += ( Dv*laplacian(V) + U*V**2 - (F+k)*V     )

    if i % skip == 0:
        P[j] = U
        j += 1

make_ani(P)









# (Du, Dv, F, k) = ((0.16, 0.08, 0.035, 0.065)) # Bacteria 1
# (Du, Dv, F, k) = ((0.14, 0.06, 0.035, 0.065)) # Bacteria 2
(Du, Dv, F, k) = ((0.16, 0.08, 0.060, 0.062)) # Coral
# (Du, Dv, F, k) = ((0.19, 0.05, 0.060, 0.062)) # Fingerprint
# (Du, Dv, F, k) = ((0.10, 0.10, 0.018, 0.050)) # Spirals
# (Du, Dv, F, k) = ((0.12, 0.08, 0.020, 0.050)) # Spirals Dense
# (Du, Dv, F, k) = ((0.10, 0.16, 0.020, 0.050)) # Spirals Fast
# (Du, Dv, F, k) = ((0.16, 0.08, 0.020, 0.055)) # Unstable
# (Du, Dv, F, k) = ((0.16, 0.08, 0.050, 0.065)) # Worms 1
# (Du, Dv, F, k) = ((0.16, 0.08, 0.054, 0.063)) # Worms 2
# (Du, Dv, F, k) = ((0.16, 0.08, 0.035, 0.060)) # Zebrafish

N = 256

U = np.zeros((N,N)) # Clear Chemicals
V = np.zeros((N,N))

U = U + 1.0
r = 5
U[N//2-r:N//2+r,N//2-r:N//2+r] = 0.50 # Add Disturbance in Center Square Radius r
V[N//2-r:N//2+r,N//2-r:N//2+r] = 0.25

U += 0.05*np.random.random((N,N)) # Add Noise to Chemicals
V += 0.05*np.random.random((N,N))

U = torch.from_numpy(U)[None,None,:,:].type(torch.float).cuda()
V = torch.from_numpy(V)[None,None,:,:].type(torch.float).cuda()

steps = 8000
skip = 100
P = torch.zeros((steps,N,N)) # storage for frames for animation

j = 0 #same as before
for i in range(steps*skip):

    U += ( Du*laplacian(U) - U*V**2 +  F   *(1-U) )
    V += ( Dv*laplacian(V) + U*V**2 - (F+k)*V     )

    if i % skip == 0:
        P[j] = U
        j += 1

make_ani(P)

