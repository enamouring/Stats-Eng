# -*- coding: utf-8 -*-
"""Audrey_Lab 9_Load MNIST.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YTCEIDIpaJhXweOCHxBciu1tuFwVmZsa
"""

import torch
from torchvision import datasets, transforms

# Define a transform to normalize the data
transform = transforms.Compose([transforms.ToTensor()])

# Download and load the MNIST training data
train_data = datasets.MNIST(root='./data', train=True, download=True, transform=transform)

# Extracting the data and targets as tensors
train_images = train_data.data
train_labels = train_data.targets

train_images.shape, train_labels.shape

import matplotlib.pyplot as plt
import numpy as np

28*28

train_images[0,:,:] #select the image from the training dataset

x = train_images[0,:,:] #assign to x

plt.imshow(x) #shows x with its corresponding color values

train_labels[0]

x.shape #28x28

x.flatten()

x = x.flatten() #10x1, 10 bits

x.shape #784 when flattened

x = x.reshape(28,28) #reshape to 28x28

x.shape

#y=mx, matrix multiplication y=mx+b where b is bias term

m=torch.rand((10,784))

m.shape

x=x.flatten();x #type is too large, have to scale down for matrix multiplication

x=x/255.0 #to get percentages (float)

m.shape,x.shape #displays the shape of both m and x

m@x #matirix multiplication (other options: torch.matmul(arg1,arg2))

y=m@x #define y as the matrix multiplication between m and x

max(y) #or torch.max

torch.argmax(y) #second position in array (0 corresponds to 0, 1 corresponds to 1, etc.)

x=train_images[0:25,:,:]/255

x.shape

x=x.reshape(25,784)

x.shape

x=x.T #take the transpose
x.shape

z=m@x;z #matirix multiplication and recall z

z.shape #displays the shape of z (10x25)

plt.imshow(z) #shows the plot of z, with color coordination to signify numbers

torch.max(z) #states the maximum value in z
torch.argmax(z,0) #returns the indexes of max values in each column of z

